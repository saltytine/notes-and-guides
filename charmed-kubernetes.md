# Charmed Kubernetes

See official documentation [here](https://documentation.ubuntu.com/canonical-kubernetes/latest/).  
Charmed Kubernetes is Canonical’s enterprise Kubernetes distribution, designed to provide a model-driven, fully managed container orchestration platform on Ubuntu.  It uses Juju “charms” to model and operate each Kubernetes component, enabling automated deployment, upgrades, and scaling of clusters on any infrastructure.  In practice, a Juju controller and model define the cluster topology – for example, an etcd cluster charm, multiple kubernetes-control-plane units, and kubernetes-worker units – with charms for network, storage, and other services all related together.  This approach makes Charmed K8s highly modular and adaptable to environments from bare-metal to public cloud.  The architecture diagram below illustrates this model-driven design: Juju sits at the center orchestrating container runtimes (e.g. containerd or Kata), CNIs (Calico/Flannel), storage (Ceph), and observability (Prometheus, Grafana, Loki, etc.) in a unified stack.

The design philosophy is declarative and “Day-2” automated – Charmed Kubernetes aims to manage the entire lifecycle (deployment, updates, scaling, failure recovery) without manual intervention.  By default every core Kubernetes service is delivered as a Juju charm.  For example, the kubernetes-control-plane charm runs the API server, controller-manager, and scheduler; the kubernetes-worker charm runs kubelet, kube-proxy and a container runtime; and the etcd charm runs a TLS-enabled etcd cluster.  This means updates (via Juju “charm refresh” or snap refresh) and configuration changes (via Juju model configs) can be applied uniformly to all units.  Because the bundle uses Ubuntu snaps for Kubernetes binaries, OS and security patches are delivered automatically, ensuring CNCF-certified Kubernetes with up-to-date fixes.  Charmed K8s also supports advanced infrastructure features: e.g. full OCI compatibility (containerd and Docker), PCI passthrough (GPU/FPGA/SR-IOV), and multi-arch (x86/ARM) for IoT/edge use.

## Components

Charmed K8s breaks Kubernetes down into Juju-managed charms.  Core components and their deployment are:

* Kubernetes Control Plane (kubernetes-control-plane charm): This charm installs and configures the API server, controller-manager, and scheduler on master nodes.  It is deployed with multiple units for HA, and is usually fronted by a load-balancer or VIP (see HA section).  The control-plane charm also relates to easyrsa or vault for TLS certs, and to other charms like LB or ingress as needed.
* etcd (etcd charm): Etcd runs as a separate charm providing a TLS-terminated clustered key-value store.  The etcd charm typically runs 3 or 5 units for quorum and is automatically bootstrapped via Juju.  It stores all Kubernetes state and supports snapshots via Juju actions.  The charm uses the EasyRSA CA for its own certificates (see Security).
* Kubernetes Worker (kubernetes-worker charm): Worker nodes run the kubelet and kube-proxy.  This charm also installs the container runtime (by relating in a runtime charm) and the chosen CNI (Flannel/Calico/etc.) as subordinates.  Workers register themselves with the control plane automatically.
* Container Runtime: Charmed K8s primarily uses containerd (via the containerd subordinate charm) as the runtime (support for Docker was removed in v1.24).  The containerd charm can be configured (e.g. registry-mirror, registry-auth, or GPU support) and related to kubernetes-worker and kubernetes-control-plane charms.  Optionally, Kata Containers can be enabled by deploying the kata charm alongside containerd; since v1.16, Kata provides VM isolation for untrusted pods.
* Networking (CNI): By default Charmed K8s deploys Calico for pod networking.  Alternative CNIs (Flannel, Canal, Cilium, Tigera, etc.) can be deployed via Juju overlays or by relating their charms to the workers.  For example, the flannel or canal charms can be related to kubernetes-worker for layer-3 connectivity.  MetalLB can be used on bare-metal to provide external IPs to services.
* Ingress/Load Balancing: The kubeapi-load-balancer charm (nginx) or cloud LBs can provide a front-end for the API servers in HA setups.  Similarly, ingress controllers (NGINX, contour, etc.) and load balancers can be deployed via charm.  Charmed K8s bundles often use keepalived or MetalLB to implement virtual IPs for control-plane HA.
* Storage: Charmed K8s can integrate with Ceph or other storage backends.  In an overlay, operators deploy ceph-mon and ceph-osd charms to form a Ceph cluster, then deploy the ceph-csi charm to provide RBD/CephFS storage classes.  PersistentVolumes are then provisioned via standard PVCs.  (Alternatively, cloud volumes, or local volumes can be used.)
* Others: Many complementary services have charms that integrate seamlessly.  For TLS and cert management, the easyrsa charm acts as a CA for all other charms.  For logging/monitoring, there are prometheus2, grafana, loki, alertmanager, filebeat, etc. (see Observability).  For compliance/security, the cis-benchmark action in the control-plane/worker/etcd charms can evaluate CIS compliance.  Operators (charms) for apps (databases, caches, etc.) can be related to the cluster via Juju or deployed in the cluster itself.

## Juju Integration

Charmed Kubernetes is built on Juju’s model-driven operations paradigm.  The Juju controller orchestrates the lifecycle of every component via charms and relations.  A Juju model encapsulates one Kubernetes cluster (with its controller, units, and relationships).  The Juju controller and models are portable – you can create models in any cloud, bare-metal, or even on-premises via MAAS.  Common charms used in the default Charmed K8s bundle include easyrsa, etcd, kubernetes-control-plane, kubernetes-worker, kubeapi-load-balancer, plus subordinate charms for CNI (flannel, calico, etc.), storage (ceph-csi, rook, etc.), and compute (docker, containerd, kata).  Each charm declares the interfaces it provides/requires.  For example, kubernetes-control-plane requires a TLS cert provider and provides endpoints for juju-info (used for monitoring) and kubecontrolplane relations.  Juju relations automatically exchange configuration: e.g., the kubernetes-control-plane:prometheus relation to prometheus2:manual-jobs ensures Prometheus scrapes the API server.  Lifecycle hooks in each charm handle events: on config-changed a charm reconfigures the underlying component, on upgrade-charm it performs in-place upgrades, etc.  This means adding a machine and running juju add-unit will deploy the charm, configure the service, and join it to the cluster.  As Ubuntu’s documentation notes, “every service is driven by a charmed operator”, enabling automated integration and updates.

Juju also provides overlays and bundles.  Bundles (e.g., charmed-kubernetes) specify a set of charms and relations for a complete cluster.  Overlays can modify the bundle (e.g. to switch CNI or add monitoring).  For example, a monitoring overlay relates prometheus, grafana, telegraf to the control-plane and workers as shown in the documentation.  Juju’s model abstraction enables multi-cluster topologies and multi-cloud deployment via Juju controllers that span clouds.  In short, Charmed K8s leverages Juju’s whole-application orchestration model: engineers simply declare the desired topology and Juju charms take care of bootstrapping, configuration, and day-2 tasks.

## Deployment and Lifecycle Management

Charmed Kubernetes clusters are typically deployed via Juju bundles on a Juju model.  By default, the charmed-kubernetes bundle will deploy a single control-plane unit (plus etcd and easyrsa) and one or more workers.  For production, an HA topology is used (see below).  The deployment sequence (as in a bundle) is generally: bootstrap Juju controller, add target machines (e.g. with juju add-machine), then juju deploy charmed-kubernetes --overlay <custom.yaml>.  Juju will provision machines (or spin up VMs), install charms and snaps, and relate them.  For example, in a minimal core setup Juju would install one unit each of kubernetes-control-plane, etcd, and easyrsa on a machine, and one kubernetes-worker on another.  The control-plane registers with etcd (via the tls-certificates interface), and the worker registers with the API server.  The installer then provides a kubeconfig to allow kubectl access.

### High Availability

Charmed K8s supports HA out-of-the-box.  The documentation recommends deploying multiple control-plane units with a front-end load balancer or VIP.  For example, one common pattern is to add 3 kubernetes-control-plane units, and deploy the kubeapi-load-balancer (Nginx) charm with juju deploy kubeapi-load-balancer.  Then relate it to all control-plane units; the workers use the LB’s IP to reach the API.  Alternatively on bare-metal, the keepalived charm can float a virtual IP across the masters.  Regardless of method, the goal is that if one master fails, the others (behind the LB/VIP) keep the cluster alive.  Etcd itself should run in an odd-numbered quorum (3 or 5 units) so it tolerates node failures.  (By default the etcd charm is deployed with 3 units, which Juju co-locates or can distribute on separate machines.)  Worker nodes can also be scaled (via juju add-unit kubernetes-worker) without downtime.  Ingress traffic for workloads can be HA’d using MetalLB or keepalived plus any ingress controller.

### Upgrades

Charmed Kubernetes automates patch upgrades.  That is, point releases within the same minor version (e.g. 1.29.1 to 1.29.2) are automatically applied by refreshing the underlying snaps and charms.  The operator need only ensure the controller and model are updated.  Minor version upgrades (e.g. 1.28 → 1.29) require a managed process: the [upgrade documentation](https://ubuntu.com/kubernetes/charmed-k8s/docs/upgrading) instructs operators to follow specific steps, usually by revising the charms to a new channel and carefully upgrading one service at a time.  In all cases, backups are strongly recommended beforehand: make etcd snapshots and back up any PV data:contentReference[oaicite:27]{index=27}:contentReference[oaicite:28]{index=28}.  After an upgrade, juju status\ should show all units “active” with the new version.  Because the charm developers control the packaged Kubernetes, deprecated APIs or special migrations are handled in charm hooks when possible.  Operators only need to coordinate roleout (e.g. Cordoning nodes, draining workloads) as in any K8s upgrade.

### Scaling and Maintenance

Scaling is simple: add units.  E.g. juju add-unit kubernetes-worker adds another worker VM or container and automatically joins it to the cluster.  Control-plane scaling (adding masters) is possible but must be paired with HA network setup as above.  Juju also supports juju upgrade-charm which upgrades individual charms in-place; this is used for official charm upgrades or to switch from EasyRSA to Vault, etc.  For zero-downtime maintenance, Juju’s model-driven nature allows rolling upgrades: for example, one can upgrade one control-plane unit at a time or do canary tests.

Operators should monitor Juju’s built-in automatic updates: the Kubernetes snaps are updated on the machines, so it’s important to control the snap refresh schedule if needed (see “Snap Refresh Settings” in docs).  By default Ubuntu will apply security patches rapidly to all snaps, providing a “ZeroOps” experience.  The Juju charm metadata also allows setting an upstream channel for Kubernetes versions.  Overall, Charmed K8s aims for a mostly unattended lifecycle, with the operator intervening mainly for major upgrades or custom config changes.

### Backup and Restore

The etcd database holds the cluster state (objects, secrets, etc), so it must be backed up.  Charmed K8s exposes etcd’s native snapshotting via Juju actions on the etcd units.  The [backup guide](https://ubuntu.com/kubernetes/charmed-k8s/docs/explain-backups) recommends running juju run etcd/0 etcd.save (or the cis-benchmark action for the control-plane) to create a snapshot, and then copying the file off-cluster.  This etcd snapshot can later be restored if needed.  Persistent Volumes (PVs) should be backed up using storage-specific methods (e.g. Ceph RBD snapshots, cloud volume snapshots, or Kubernetes backup tools like Velero).  While Kubernetes can dynamically provision volumes, the underlying data belongs to applications.  In short, you plan backup/restore like any Kubernetes system: etcd + PV data.  Charmed K8s does not currently include a built-in Velero charm, but such tools can be deployed on the cluster via Helm or operators.

## Networking and Storage Integrations

Network: Charmed K8s uses a Container Networking Interface (CNI) plugin for pod networking.  By default it deploys Calico, which supports BGP/Overlay networking and network policy.  Calico is installed as a subordinate charm to the worker/control-plane and configures the cluster network.  Alternately, Flannel or Canal (Flannel+Calico) are available charms.  To switch, one uses a Juju overlay that removes the default Calico relation and adds the new CNI charm.  For L2 load balancing (for Services of type=LoadBalancer), MetalLB can be deployed (canonical provides metallb-speaker and metallb-controller charms) and IP addresses allocated for VIPs on bare-metal.  In the cloud, operators typically use the cloud’s own LB (via the AWS/Azure/GCP integrator charms).  For ingress to cluster services, any Ingress controller (NGINX, Contour, Traefik, etc.) can be deployed via its Juju charm or a Helm chart.

Storage: Charmed K8s integrates with block and file storage via CSI drivers.  For example, to use Ceph, an operator deploys ceph-mon and ceph-osd charms to form a Ceph cluster, then the ceph-csi charm to provide RBD and CephFS volume classes.  The bundles in CharmHub often include these for ease.  PVs are then provisioned by creating PersistentVolumeClaims using those storage classes.  Other CSI drivers (AWS EBS, Azure Disk, CSI-CSI for GCP) can also be used via cloud provider operator charms.  Juju itself can also manage storage integrations: for instance, the csi:rbd storage relation from kubernetes-control-plane to ceph-rbd populates the necessary secrets and endpoints in the cluster.  In practice, any Kubernetes volume type is supported as long as there’s a Charms or cloud service backing it.

## Observability Stack

Charmed K8s supports a full monitoring and logging stack, typically deployed as additional charms in the model.  For metrics, the recommended approach is Prometheus + Grafana with Telegraf.  One can deploy the prometheus2 charm and grafana charm, then relate them: e.g., prometheus:grafana-source to grafana:grafana-source for dashboards.  The workers and control-plane expose Prometheus endpoints via the scrape interface, so adding relations such as [kubernetes-worker:scrape, prometheus:scrape] and [kubernetes-control-plane:prometheus, prometheus:manual-jobs] wires in all metrics.  Telegraf can be related to collect node-level metrics (juju-info) from each unit.  The official Charmed K8s monitoring overlay (shown below) demonstrates these relations.  Once set up, Grafana provides cluster and node dashboards (built-in in the charm, or via Grafana Labs’ Kubernetes dashboards).

For logging, Charmed K8s originally recommended Graylog (ELK-like) via filebeat forwarding.  The docs include a Graylog bundle overlay with graylog, elasticsearch, mongodb, and filebeat charms.  However, Canonical now favors Loki (the “Prometheus for logs”) as part of the new LMA2 stack.  Loki (and Grafana Agent) can be deployed and related to gather logs: for example, each juju unit forwards its logs to Loki.  Alerting is handled by Alertmanager (charmed alertmanager-k8s), which is integrated with Prometheus (alerts firing based on Prom rules) and Loki.  Grafana is the single pane for both metrics and logs.

&#x20;The figure above is an example observability model diagram: a lightweight K8s cluster running the Canonical Observability Stack (Prometheus, Loki, Grafana, Grafana Agent, Alertmanager).  The Grafana Agent collects telemetry from all components.  Loki ingests logs, Prometheus ingests metrics, and Grafana unifies visualization.  This Juju-based LMA (Logs/Metrics/Alerts) architecture makes monitoring of Charmed K8s clusters scalable and self-hosted.

In summary, Charmed K8s provides integrated observability: built-in support for Prometheus endpoints on each service, easy deployment of Prometheus/Grafana Loki charms, and even Grafana dashboards out-of-the-box.  Alerts are defined in the Alertmanager charm and can be fine-tuned as needed.  Telegraf or Grafana Agent handle system metrics, while Loki (or Graylog) collects container/app logs.

## Add-ons and Ecosystem

Beyond core Kubernetes, Charmed K8s integrates with a wide ecosystem:

* MicroK8s: Although a separate distribution, MicroK8s is Canonical’s lightweight single-node Kubernetes (installed via snap).  It is often used for edge/IoT or development.  Canonical provides charms and tools to manage fleets of MicroK8s as well.  In some workflows, Charmed K8s can interact with MicroK8s clusters (e.g., via Azure Arc or multi-model Juju setups).
* Charmed Operators for Apps: The Juju CharmHub contains many “Charmed Operators” for cloud-native apps (databases, messaging, ML platforms, etc.).  These can be deployed on top of Charmed K8s or related into it.  For example, Canonical offers Charmed Kubeflow and Charmed Kafka, which use Juju to deploy complex app stacks on the cluster.
* Service Mesh (Istio): Canonical provides an Istio bundle.  The istio charm (or sub-charms like istio-gateway, istio-pilot) can be deployed on a Charmed K8s cluster to enable service mesh.  For instance, juju deploy istio (bundle) installs Istio components which then mesh the services.  (See CharmHub “Istio bundle” for details.)  Once related (e.g. labeling namespaces), Istio functionality (sidecar injection, ingress gateway) is enabled.
* Serverless (Knative): Canonical maintains Knative charms: knative-operator, knative-serving, knative-eventing.  Operators can deploy Istio first (as Knative requires a mesh), then deploy these Knative charms via Juju.  This sets up Kubernetes-native serverless on Charmed K8s, enabling auto-scaling to zero, eventing, etc.  Metrics for Knative are scraped by Prometheus (via relations shown in the Knative operators doc).
* Edge/IoT Use Cases: Charmed K8s supports ARM architectures and low-touch deploys, making it suitable for edge.  The distribution is “fully-conformant, low-touch, self-healing Kubernetes at the edge”.  Juju can deploy to ARM servers (or LXD containers on ARM), and charms like MetalLB work on multi-arch.  The same model-driven ease is valuable for telco edge, retail kiosks, etc.  Canonical has documented reference architectures for telco and multi-access edge, often using Charmed K8s atop MAAS or public cloud.

## Security Model

Security is integrated at multiple levels in Charmed K8s:

* RBAC: By default, Charmed Kubernetes enables RBAC for API access.  The kubernetes-control-plane charm sets the API server’s --authorization-mode=Node,RBAC.  The “AlwaysAllow” mode is disabled, and a webhook token authenticator (via --token-auth-file disabled and migrated to secrets) ensures only proper credentials are used.  Node and Pod restrictions are also enabled (e.g. NodeRestriction admission plugin).  The K8s Dashboard and other add-ons should be configured with least-privilege roles.  (Juju’s own permissions control access to the cluster via the controller.)
* TLS: All intra-cluster communication is secured by TLS.  The easyrsa charm acts as a Certificate Authority, issuing certificates to all Kubernetes components.  The Kubernetes API, etcd cluster, Kubelets, and controller components all use TLS for mutual authentication.  For example, etcd is “TLS-terminated” in its charm, meaning client and peer traffic is encrypted.  If desired, Vault can replace EasyRSA for certificate management by deploying a Vault charm and relating it.
* Secrets Management: For storing sensitive data, you can deploy a Vault (Hashicorp) charm, which provides a secure secret store for the cluster.  The vault charm is listed as compatible with Charmed K8s.  Additionally, Charmed K8s can integrate OPA Gatekeeper or the new OPA policy controller to enforce policies on secrets, configs, etc.  (Recent releases include an OPA policy-controller charm as noted in release notes.)
* Compliance and Hardening: Charmed K8s adheres to CIS Kubernetes Benchmark by default.  The charms have been audited: for example, the control-plane charm’s CIS profile ensures --profiling is disabled and a Kubernetes encryption config is enabled.  The worker charm enables kernel hardening flags (protect-kernel-defaults) and disables the insecure Kubelet port.  The built-in cis-benchmark Juju action can be run on each unit to report compliance, and auto-remediation flags are available.  Because Charmed K8s uses Ubuntu, common security features like AppArmor profiles, seccomp, and ESM are inherited.  Canonical also provides an “Ubuntu CIS-compliant Kubernetes” documentation set for operators to lock down their cluster.

## CI/CD Integration and Automation

Charmed K8s fits into modern CI/CD workflows through GitOps and operators.  For GitOps, Juju can be integrated with systems like Azure Arc or Flux: for example, Canonical announced Azure Arc support, where Charmed K8s clusters can be managed declaratively via Git repos.  In practice, this means cluster manifests (Juju bundles, charms channels, Kubernetes YAML) can be kept in Git, and changes applied via automation.  Juju itself can be scripted: one could run Juju CLI commands in GitHub Actions or Jenkins pipelines to spin up a model, deploy charms, or relate services.  For instance, operators often use Juju’s GitHub Actions (see Juju’s examples) to perform repeatable deploys.

For pipeline automation, Jenkins can be deployed on the Kubernetes cluster using the jenkins-k8s-operator charm.  This provides a continuous integration server managed by Juju; pipeline jobs can be created to build and test applications on the cluster.  The Jenkins Kubernetes Operator allows dynamic provisioning of Jenkins agents as pods.  Alternatively, teams often run Jenkins or other CI servers outside the cluster and use Juju or kubectl calls in their pipeline scripts.  Canonical’s own CI for Charmed K8s uses Jenkins and GitHub Actions (e.g. the charmed-kubernetes/jenkins repository) to build and test releases.

In short, Charmed K8s does not mandate a specific CI tool – it is fully compatible with GitOps (via Flux/Argo/GitHub Actions for Kubernetes apps, and Juju-managed GitOps for infra) and with Jenkins pipelines.  The jenkins-k8s-operator and community GitHub Action examples show how tightly Juju can integrate with CI/CD pipelines.

## Troubleshooting and Best Practices

Monitoring health: In day-to-day ops, use Juju tools to inspect the cluster.  juju status --color gives an overview: each charm’s Workload and Agent status, units and machines.  A healthy deployment will show all units as active (green) with messages like “Ready” or “Kubernetes master running”.  If something is down, juju status will show error or blocked.  You can narrow focus to a component (e.g. juju status kubernetes-worker).  The Juju agent logs and machine logs can be viewed via juju debug-log, which tails logs across all units.  Useful filters (by unit or level) help pinpoint errors.

Inspecting logs: By default, Juju centralizes unit logs on the controller, but you can also juju ssh into any unit’s machine and inspect logs under /var/log/juju/.  For Kubernetes-level logs (pod logs), use kubectl logs as usual.  For cluster logs (audit, system components), you may use the Graylog or Loki stack mentioned above.  If a control-plane or etcd issue arises, check those unit’s logs directly with juju ssh kubernetes-control-plane/0 and journalctl -u snap.kube-apiserver.

Useful tools: The Juju community provides juju-crashdump, a script that collects a complete bundle of logs, configs, and status from a model.  Running juju-crashdump (with debug-layer and config flags) on your controller creates a tarball that is very helpful for diagnosing complex failures or when filing bug reports.  This captures snap versions, systemd output, unit counters, etc.

Common issues: A few caveats have been observed in production: e.g. deployments on the localhost (LXD) cloud sometimes suffer LXD profile mismatches on charm upgrades.  If units in LXD fail to restart after an upgrade, check that the auto-generated LXC profiles (shown via juju machines --format=yaml) have the correct nesting and mount settings, and manually fix with lxc profile edit if needed.  Another known issue is Helm v2 (Tiller) hitting a LB bug on Juju; the troubleshooting docs cover how to redeploy Helm v2 or skip Tiller in favor of Helm v3.

Best practices:

* Always use Juju relations for any integration (do not, for example, manually configure access outside of Juju).
* Keep Juju and models up-to-date (Juju itself can be upgraded via snap refresh juju).
* Use snap refresh schedules to control when OS and Kubernetes updates apply.
* Regularly run the cis-benchmark actions to ensure no drift from secure settings.
* Test upgrades in a staging model first.

In field deployments, operators find Charmed K8s reliable, failures are rare because Juju restarts crashed services, relocates units, or triggers leader re-election.  Most day-to-day troubleshooting is just examining Juju’s status and logs, applying charm actions and letting charms handle the details.
